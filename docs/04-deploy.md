# AWS 배포 설명

## 1. EC2를 선택한 이유

이번 프로젝트의 배포 환경으로 **AWS EC2 (Elastic Compute Cloud)**를 선택.
PaaS(Platform as a Service) 서비스들과 달리 IaaS(Infrastructure as a Service)는 **OS(리눅스) 수준의 접근 권한**을 제공받아, 개발자가 원하는 환경(Docker, Java 버전, Swap 메모리 설정 등)을 자유롭고 정밀하게 제어할 수 있기 때문.  
 Docker를 직접 설치하고 컨테이너의 생태계를 직접 구축,
서버에 접속(SSH), 배포스크립트(CI/CD)를 짜는 경험을 통해 서버 인프라에 대한 이해도를 높이고자 하였다.

## 2. 보안 그룹 설정 이유

AWS 보안 그룹(Security Group)은 클라우드 상의 방화벽 역할을 한다.  
외부에서 서버로 들어오는 트래픽을 제어하기 위해 다음과 같이 포트를 개방

- **22 (SSH):** 관리자(개발자)가 서버에 원격 접속하여 명령어를 실행하거나, GitHub Actions가 자동 배포를 위해 접속하는 통로. 보안을 위해 관리자의 IP 또는 GitHub Action의 접근만 허용.
- **3000 (Frontend):** 일반 사용자가 웹 브라우저를 통해 **Next.js 웹 사이트**에 접속할 때 사용하는 포트입니다. 어디서든 접속할 수 있어야 하므로 전체 개방(`0.0.0.0/0`)
- **8080 (Backend):** 프론트엔드(브라우저)가 **Spring Boot API** 데이터를 요청할 때 사용하는 포트. 클라이언트 사이드 렌더링(CSR) 방식의 통신을 위해 전체 개방(`0.0.0.0/0`)

## 3. 서버에서 실행한 명령 흐름

EC2 인스턴스를 처음 생성한 후, 서비스를 띄우기 위해 다음과 같은 과정을 거침.

1.  **기본 환경 설정:**

    - `sudo dnf update -y`: 리눅스 패키지들을 최신 버전으로 업데이트.
    - `sudo fallocate ...`: 저사양 인스턴스에서 빌드 중 메모리 부족으로 서버가 멈추는 것을 방지하기 위해 Swap 메모리(가상 메모리)를 2GB 할당.

2.  **필수 프로그램 설치:**

    - **Git:** 소스 코드를 가져오기 위해 설치.
    - **Java 21 (Corretto):** Spring Boot 백엔드 빌드를 위해 설치.
    - **Docker & Docker Compose:** 컨테이너 기반의 애플리케이션을 실행하고 관리하기 위해 설치.

3.  **프로젝트 배포 및 실행:**
    - `git clone ...`: GitHub에서 최신 프로젝트 코드를 서버로 다운로드.
    - `.env 파일 생성`: DB 비밀번호 등 민감한 정보를 환경 변수 파일로 생성.
    - `chmod +x gradlew`: 백엔드 빌드 도구에 실행 권한을 부여.
    - `docker-compose up -d --build`: 프론트엔드, 백엔드, DB를 빌드하고 백그라운드 모드로 실행.

## 4. 배포 후 접속 방식

배포가 완료된 후 사용자는 브라우저를 통해 다음과 같이 접속.

- **접속 주소:** `http://{EC2_퍼블릭_IP}:3000`
- **동작 원리:**
  1.  사용자가 브라우저 주소창에 위 주소를 입력.
  2.  요청이 AWS 방화벽(3000번 포트)을 통과해 EC2 서버에 도달.
  3.  Docker가 이 요청을 **프론트엔드 컨테이너**로 전달.
  4.  화면이 로딩된 후, 게시글 목록 등을 불러오기 위해 브라우저는 다시 `http://{EC2_퍼블릭_IP}:8080`으로 API 요청을 보냄.
  5.  이 요청이 **백엔드 컨테이너**로 전달되어 DB 데이터를 조회 후 응답.
